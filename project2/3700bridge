#!/usr/bin/python -u
# The -u makes output unbuffered, so it will show up immediately
import sys
import socket
import select
import json
import time

# Pads the name with null bytes at the end
def pad(name):
	result = '\0' + name
	while len(result) < 108:
		result += '\0'
	return result


# Create a JSON string representation of a packet
def packet(source, dest, form, message):
	packet = {'source': source, 'dest': dest, 'type':form, 'message':message}
	return packet


# Send a BPDU packet
def send_bpdu():
	message = {'id': id, 'root': root, 'cost': cost}
	# Calls select with all the sockets; change the timeout value (1)
	read, write, ignore2 = select.select(sockets, sockets, [], 1)
	for x in write:
		port_num = sockets.index(x)
		# Create and send the BPDU JSON packet
		p = packet(id + "/" + str(port_num), 'ffff', 'bpdu', message)
		if port_num not in BPDUs:
			BPDUs[port_num] = (p, time.time)
		else:	
			better = comp_bpdu(BPDUs[port_num][0], p)
			if better:
				better['message']['cost'] = better['message']['cost'] + 1
				BPDUs[port_num] = (better, time.time())
		x.sendall(str(json.dumps(p)))


# Send a message to all sockets
def send_message(ports_to_send, message):
	# Calls select with all the sockets; change the timeout value (1)
	read, write, ignore2 = select.select(ports_to_send, ports_to_send, [], 1)
	for x in write:
		x.sendall(message)


# Determine the type of a packet and read the data
def read_packet(data, port):
	data = json.loads(data)
	if data['type'] == 'bpdu':
		# The packet is a BPDU packet
		return read_bpdu(data['message'], data, port)
	elif data['type'] == 'data':
		# The packet is of some other type
		return process_data(data, port)


# Process a non-BPDU packet
def process_data(data, port):
	global forwarding_table
	if port in designated_ports:
		print "Received message " + str(data['message']['id']) + " on port " + str(sockets.index(port)) + " from " + data['source'] + " to " + data['dest']
		if data['source'] not in forwarding_table:
			# Create a forwarding table entry for the source of the packet if one does not already exist
			forwarding_table[data['source']] = (port, time.time())
		if data['dest'] in forwarding_table:
			# If the destination of the packet is in the forwarding table, send to proper port
			print "Forwarding message " + str(data['message']['id']) + " to port " + str(sockets.index(port))
			send_message([forwarding_table[data['dest']][0]], str(json.dumps(data)))
		else:
			# If the destination of the packet is NOT in the forwarding table, send to designated port and root port
			ports_to_send = designated_ports + [root_port] if root_port is not None else designated_ports
			print "Broadcasting message " + str(data['message']['id']) + " to all ports"
			send_message(ports_to_send, str(json.dumps(data)))
	else: 
		print "Not forwarding message " + str(data['message']['id'])

# Compare two BPDUs, return the second if it's better, otherwise return None
def comp_bpdu(packet1, packet2):
	data1 = packet1['message']
	data2 = packet2['message']
	
	if int(data2['root'], 16) < int(data1['root'], 16):
		return packet2
	if int(data2['root'], 16) == int(data1['root'], 16):
		if data2['cost'] < data1['cost']:
			return packet2
		if data2['cost'] == data1['cost'] and int(packet2['source'].split("/")[0], 16) < int(packet1['source'].split("/")[0], 16):
			return packet2
	return None

# go through the BPDUs for each port, updating root port and designated ports
# def process_bpdus():
	# global BPDUs, root, cost
	# for key, val in BPDUs:
		# data = val[0]
		# # BPDU shows a lower ID root
		# if int(data['message']['root'], 16) < int(root, 16):
			# # BPDU shows a lower or equal cost
			# root = data['message']['root']
			# cost = data['message']['cost']
			# # NEW ROOT PORT
		# # BPDU matches our known root ID
		# elif int(data['message']['root'], 16) == int(root, 16):
			# # BPDU shows a lower cost on this port
			# if data['message']['cost'] < cost:
				# cost = data['message']['cost']
				# # NEW ROOT PORT
			# # BPDU shows an equal cost for this port
			# elif data['message']['cost'] == cost:
				# # Source ID of this bpdu lower than current RP
				# if int(data['source'], 16) < int(BPDUs[sockets.index(root_port)]['source'], 16):
					# # NEW ROOT PORT
				# # Source ID of this bpdu equal to current RP
				# elif int(data['source'], 16) == int(BPDUs[sockets.index(root_port)]['source'], 16):
					# # determine behavior for this


def designate_port(port, source):
	global designated_ports
	if port not in designated_ports:
		designated_ports.append(port)
		print_ports()
		
def disable_port(port, port_num):
	global designated_ports
	if port in designated_ports:
		designated_ports.remove(x)
		print_ports()
		
def print_ports():
	s = "DESIGNATED: "
	for port in designated_ports:
		s = s + " " + str(sockets.index(port))
	if root_port:
		s = s + "\nROOT: " + str(sockets.index(root_port))
	else:
		s = s + "\nROOT: None"
	print s


# Read the BPDU packet and take neccesary actions
def read_bpdu(data, packet, port):
	global cost, root, root_port, designated_ports, forwarding_table, BPDUs
	port_num = sockets.index(port)
	d_root = data['root']
	d_cost = data['cost']
	
	# Handle receiving our own BDPU
	d_source_id, d_source_port = packet['source'].split("/")
	if d_source_id == id:
		if d_source_port == port_num:
			# The BPDU was sent on this port, designate this port
			designate_port(port, packet['source'])
		else:
			# The BPDU was sent on a different port, disable this port
			disable_port(port, port_num)

	if port_num in BPDUs:
		better = comp_bpdu(BPDUs[port_num][0], packet)
		if better:
			better['message']['cost'] = better['message']['cost'] + 1
			BPDUs[port_num] = (better, time.time())
	else:
		temp = packet
		packet['message']['cost'] = packet['message']['cost'] + 1
		BPDUs[port_num] = (temp, time.time())

	if (root_port == None or root_port != port) and root == d_root:
		if port not in designated_ports and (cost < d_cost or (cost == d_cost and int(root, 16) < int(d_root, 16))):
			# Add the port as a designated port
			designated_ports.append(port)
			# Flush the forwarding table
			for x in designated_ports:
				if x != port and x.getpeername() == port.getpeername():
					designated_ports.remove(x)
					print "Disabled port: " + id + "/" + str(port_num) + " (lower cost)"
			forwarding_table.clear()
			# print str(root_port == None or root_port != port) + "lower cost: Designated port: " + id + "/" + str(sockets.index(port))
		elif port in designated_ports:
			# If a BPDU is received from self, check all designated ports against the port it was received on
			# Remove other ports with the same addr from designated
			if data['id'] == id or root == id:
				# print data
				for x in designated_ports:
					if x != port and x.getpeername() == port.getpeername():
						designated_ports.remove(x)
						forwarding_table.clear()
						print "Disabled port: " + id + "/" + str(port_num) + " (sender = receiver)"
			else:
				designated_ports.remove(port) 
				# Flush the forwarding table
				forwarding_table.clear()
				print "Disabled port: " + id + "/" + str(port_num) + " (port not designated)"
	
	if (d_cost == cost and int(d_root, 16) < int(root, 16)) or (d_cost < cost):
		# If bridge_id of BPDU is less than current, change the root
		root = d_root
		print "New root: " + id + "/" + root
		# Set a new root port and the associated cost + 1
		cost = d_cost + 1
		root_port = port
		print "Root port: " + id + "/" + str(port_num)
		for x in designated_ports:
			if x.getpeername() == port.getpeername():
				designated_ports.remove(x)
				print "Disabled port: " + id + "/" + str(port_num) + " (same as root)"
		# Flush the forwarding table
		forwarding_table.clear()

if __name__ == "__main__":
	# Global variables ---
	# ID of this bridge
	id = sys.argv[1]
	# IDs of rest of LAN
	LAN = sys.argv[2:]
	# List of sockets
	sockets = []
	# ID of root node for this bridge (Defaults to this bridge)
	root = id
	# Number of leaps to root (Defaults to zero)
	cost = 0
	# Port that connects to the current root node (Defaults to this bridge, None)
	root_port = None
	# List representing the bridge forwarding table
	forwarding_table = dict()
	# Best BPDU for a given port
	BPDUs = dict()

	# Creates sockets and connects to them
	for x in range(len(LAN)):
		s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
		s.connect(pad(LAN[x]))
		sockets.append(s)

	# List of designated ports
	designated_ports = list(sockets)
	print_ports()
	print "Bridge " + id + " starting up"

	# Current time, serves to start a timer
	send_bpdu()
	t = time.time()
	# Main loop
	while True:
		for key in forwarding_table.keys():
			if time.time() - forwarding_table[key][1] > 5:
				del forwarding_table[key]
		# Calls select with all the sockets; change the timeout value (1)
		ready, ignore, ignore2 = select.select(sockets, [], [], 1)
		# Reads from each of the ready sockets
		for x in ready:
			data = x.recv(1500)
			read_packet(data, x)

		# If 500ms has passed, send out BPDUs
		if (time.time() - t) > 0.5:
			send_bpdu()
			# Reset the timer
			t = time.time()
