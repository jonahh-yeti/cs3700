#!/usr/bin/python -u
# The -u makes output unbuffered, so it will show up immediately
import sys
import socket
import select
import json
import time

# Pads the name with null bytes at the end
def pad(name):
	result = '\0' + name
	while len(result) < 108:
		result += '\0'
	return result


# Create a JSON string representation of a packet
def packet(dest, form, message):
	packet = {'source': id, 'dest': dest, 'type':form, 'message':message}
	return str(json.dumps(packet))


# Send a BPDU packet
def send_bpdu():
	message = {'id': id, 'root': root, 'cost': cost}

	# Calls select with all the sockets; change the timeout value (1)
	read, write, ignore2 = select.select(sockets, sockets, [], 1)
	for x in write:
		# Create and send the BPDU JSON packet
		p = packet(x.getpeername(), 'bpdu', str(json.dumps(message)))
		x.sendall(p)


# Send a message to all sockets
def send_message(ports_to_send, message):
	for x in ports_to_send:
		x.sendall(message)


# Determine the type of a packet and read the data
def read_packet(data, port):
	data = json.loads(data)
	if data['type'] == 'bpdu':
		# The packet is a BPDU packet
		return read_bpdu(json.loads(data['message']), port)
	elif data['type'] == 'data':
		# The packet is of some other type
		return process_data(data, port)


# Process a non-BPDU packet
def process_data(data, port):
	global forwarding_table

	if port in designated_ports:
		print "Received message " + str(data['message']['id']) + " on port " + str(sockets.index(port)) + " from " + data['source'] + " to " + data['dest']
		print("FORWARDING TABLE: " + str(forwarding_table))
		if data['source'] not in forwarding_table:
			# Create a forwarding table entry for the source of the packet if one does not already exist
			forwarding_table[data['source']] = port
		if data['dest'] in forwarding_table:
			# If the destination of the packet is in the forwarding table, send to proper port
			send_message([forwarding_table[data['dest']]], str(json.dumps(data)))
		else:
			# If the destination of the packet is NOT in the forwarding table, send to designated port and root port
			ports_to_send = designated_ports + root_port if root_port is not None else designated_ports
			send_message(ports_to_send, str(json.dumps(data)))


# Read the BPDU packet and take neccesary actions
def read_bpdu(data, port):
	global cost, root, root_port, designated_ports, forwarding_table
	d_root = data['root']
	d_cost = data['cost']

	if (root_port == None or root_port != port) and root == d_root:
		if cost < d_cost or (cost == d_cost and int(root, 16) < int(d_root, 16)):
			# Add the port as a designated port
			designated_ports.append(port)
			# Flush the forwarding table
			forwarding_table.clear()
			print "Designated port: " + id + "/" + str(sockets.index(port))
		elif port in designated_ports:
			# TODO: For simple-2.conf, all ports are removed as designated eventually
			# so the test case fails. Need to fix logic to not do this and also avoid loop
			print "TEST: " + str(cost) + " --- " + str(d_cost)
			designated_ports.remove(port) 
			# Flush the forwarding table
			forwarding_table.clear()
			print "Disabled port: " + id + "/" + str(sockets.index(port))

	if (d_cost == cost and int(d_root, 16) < int(root, 16)) or (d_cost < cost):
		# If bridge_id of BPDU is less than current, change the root
		root = d_root
		print "New root: " + id + "/" + root
		# Set a new root port and the associated cost + 1
		cost = d_cost + 1
		root_port = port
		print "Root port: " + id + "/" + str(sockets.index(port))
		# Flush the forwarding table
		forwarding_table.clear()
		# Send out another round of BPDUs
		send_bpdu()
	print "DESIGNATED: " + str(designated_ports)


if __name__ == "__main__":
	# Global variables ---
	# ID of this bridge
	id = sys.argv[1]
	# IDs of rest of LAN
	LAN = sys.argv[2:]
	# List of sockets
	sockets = []
	# ID of root node for this bridge (Defaults to this bridge)
	root = id
	# Number of leaps to root (Defaults to zero)
	cost = 0
	# Port that connects to the current root node (Defaults to this bridge, None)
	root_port = None
	# List representing the bridge forwarding table
	forwarding_table = dict()

	# Creates sockets and connects to them
	for x in range(len(LAN)):
		s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
		s.connect(pad(LAN[x]))
		sockets.append(s)

	# List of designated ports
	designated_ports = list(sockets)
	print "Bridge " + id + " starting up"

	# Current time, serves to start a timer
	t = time.time()
	# Main loop
	while True:
		# Calls select with all the sockets; change the timeout value (1)
		ready, ignore, ignore2 = select.select(sockets, [], [], 1)
		# Reads from each of the ready sockets
		for x in ready:
			data = x.recv(1500)
			read_packet(data, x)

		# If 500ms has passed, send out BPDUs
		if (time.time() - t) > 0.5:
			send_bpdu()
			# Reset the timer
			t = time.time()
