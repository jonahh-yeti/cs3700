#!/usr/bin/python -u
# The -u makes output unbuffered, so it will show up immediately
import sys
import socket
import select
import json
import time

# Pads the name with null bytes at the end
def pad(name):
	result = '\0' + name
	while len(result) < 108:
		result += '\0'
	return result


# Create a JSON string representation of a packet
def packet(dest, form, message):
	packet = {'source': id, 'dest': dest, 'type':form, 'message':message}
	return str(json.dumps(packet))


# Send a BPDU packet
def send_bpdu():
	message = {'id': id, 'root': root, 'cost': cost}
	# Calls select with all the sockets; change the timeout value (1)
	read, write, ignore2 = select.select(sockets, sockets, [], 1)
	for x in write:
		# Create and send the BPDU JSON packet
		p = packet('ffff', 'bpdu', str(json.dumps(message)))
		if sockets.index(x) not in BPDUs:
			BPDUs[sockets.index(x)] = (json.loads(p), time.time)
		else:	
			better = comp_bpdu(BPDUs[sockets.index(x)][0], json.loads(p))
			if better:
				better['message']['cost'] = better['message']['cost'] + 1
				BPDUs[sockets.index(x)] = (better, time.time())
		x.sendall(p)


# Send a message to all sockets
def send_message(ports_to_send, message):
	for x in ports_to_send:
		x.sendall(message)


# Determine the type of a packet and read the data
def read_packet(data, port):
	data = json.loads(data)
	if data['type'] == 'bpdu':
		# The packet is a BPDU packet
		return read_bpdu(json.loads(data['message']), data, port)
	elif data['type'] == 'data':
		# The packet is of some other type
		return process_data(data, port)


# Process a non-BPDU packet
def process_data(data, port):
	global forwarding_table
	print "DESIG PORTS" + str(designated_ports)
	if port in designated_ports:
		print "Received message " + str(data['message']['id']) + " on port " + str(sockets.index(port)) + " from " + data['source'] + " to " + data['dest']
		if data['source'] not in forwarding_table:
			# Create a forwarding table entry for the source of the packet if one does not already exist
			forwarding_table[data['source']] = (port, time.time())
		if data['dest'] in forwarding_table:
			# If the destination of the packet is in the forwarding table, send to proper port
			print "Forwarding message " + str(data['message']['id']) + " to port " + str(sockets.index(port))
			send_message([forwarding_table[data['dest']][0]], str(json.dumps(data)))
		else:
			# If the destination of the packet is NOT in the forwarding table, send to designated port and root port
			ports_to_send = designated_ports + [root_port] if root_port is not None else designated_ports
			print "Broadcasting message " + str(data['message']['id']) + " to all ports"
			send_message(ports_to_send, str(json.dumps(data)))
	else: 
		print "Not forwarding message " + str(data['message']['id'])

# Compare two BPDUs, return the second if it's better, otherwise return None
def comp_bpdu(packet1, packet2):
	data1 = json.loads(packet1['message'])
	data2 = json.loads(packet2['message'])
	
	if int(data2['root'], 16) < int(data1['root'], 16):
		return pakcet2
	if int(data2['root'], 16) == int(data1['root'], 16):
		if data2['cost'] < data1['cost']:
			return packet2
		if data2['cost'] == data1['cost'] and int(packet2['source'], 16) < int(packet1['source'], 16):
			return packet2
	return None

# go through the BPDUs for each port, updating root port and designated ports
def process_bpdus():
	global BPDUs, root, cost
	for key, val in BPDUs:
		data = val[0]
		# BPDU shows a lower ID root
		if int(data['message']['root'], 16) < int(root, 16):
			# BPDU shows a lower or equal cost
			root = data['message']['root']
			cost = data['message']['cost']
			# NEW ROOT PORT
		# BPDU matches our known root ID
		elif int(data['message']['root'], 16) == int(root, 16):
			# BPDU shows a lower cost on this port
			if data['message']['cost'] < cost:
				cost = data['message']['cost']
				# NEW ROOT PORT
			# BPDU shows an equal cost for this port
			elif data['message']['cost'] == cost:
				# Source ID of this bpdu lower than current RP
				if int(data['source'], 16) < int(BPDUs[sockets.index(root_port)]['source'], 16):
					# NEW ROOT PORT
				# Source ID of this bpdu equal to current RP
				elif int(data['source'], 16) == int(BPDUs[sockets.index(root_port)]['source'], 16):
					# determine behavior for this


# Read the BPDU packet and take neccesary actions
def read_bpdu(data, packet, port):
	global cost, root, root_port, designated_ports, forwarding_table, BPDUs
	d_root = data['root']
	d_cost = data['cost']

	if sockets.index(port) in BPDUs:
		better = comp_bpdu(BPDUs[sockets.index(port)][0], packet)
		if better:
			better['message']['cost'] = better['message']['cost'] + 1
			BPDUs[sockets.index(port)] = (better, time.time())
	else:
		temp = packet
		packet['message']['cost'] = packet['message']['cost'] + 1
		BPDUs[sockets.index(port)] = (temp, time.time())

	if (root_port == None or root_port != port) and root == d_root:
		if port not in designated_ports and (cost < d_cost or (cost == d_cost and int(root, 16) < int(d_root, 16))):
			# Add the port as a designated port
			designated_ports.append(port)
			# Flush the forwarding table
			for x in designated_ports:
				if x != port and x.getpeername() == port.getpeername():
					designated_ports.remove(x)
					print "lower cost: Disabled port: " + id + "/" + str(sockets.index(x))
			forwarding_table.clear()
			print str(root_port == None or root_port != port) + "lower cost: Designated port: " + id + "/" + str(sockets.index(port))
		elif port in designated_ports:
			# IF a BPDU is received from self, check all designated ports against the port it was received on
			# Remove other ports with the same addr from designated
			if data['id'] == id or root == id:
				print data
				for x in designated_ports:
					if x != port and x.getpeername() == port.getpeername():
						designated_ports.remove(x)
						forwarding_table.clear()
						print "sender = receiver: Disabled port: " + id + "/" + str(sockets.index(x))
			else:
				designated_ports.remove(port) 
				# Flush the forwarding table
				forwarding_table.clear()
				print "port not designated: Disabled port: " + id + "/" + str(sockets.index(port))
	
	if (d_cost == cost and int(d_root, 16) < int(root, 16)) or (d_cost < cost):
		# If bridge_id of BPDU is less than current, change the root
		root = d_root
		print "New root: " + id + "/" + root
		# Set a new root port and the associated cost + 1
		cost = d_cost + 1
		root_port = port
		print "Root port: " + id + "/" + str(sockets.index(port))
		for x in designated_ports:
			if x.getpeername() == port.getpeername():
				designated_ports.remove(x)
				print "same as root: Disabled port: " + id + "/" + str(sockets.index(x))
		# Flush the forwarding table
		forwarding_table.clear()

if __name__ == "__main__":
	# Global variables ---
	# ID of this bridge
	id = sys.argv[1]
	# IDs of rest of LAN
	LAN = sys.argv[2:]
	# List of sockets
	sockets = []
	# ID of root node for this bridge (Defaults to this bridge)
	root = id
	# Number of leaps to root (Defaults to zero)
	cost = 0
	# Port that connects to the current root node (Defaults to this bridge, None)
	root_port = None
	# List representing the bridge forwarding table
	forwarding_table = dict()
	# Best BPDU for a given port
	BPDUs = dict()

	# Creates sockets and connects to them
	for x in range(len(LAN)):
		s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
		s.connect(pad(LAN[x]))
		sockets.append(s)

	# List of designated ports
	designated_ports = list(sockets)
	print "DESIG PORTS" + str(designated_ports)
	print "Bridge " + id + " starting up"

	# Current time, serves to start a timer
	send_bpdu()
	t = time.time()
	# Main loop
	while True:
		for key in forwarding_table.keys():
			if time.time() - forwarding_table[key][1] > 5:
				del forwarding_table[key]
		# Calls select with all the sockets; change the timeout value (1)
		ready, ignore, ignore2 = select.select(sockets, [], [], 1)
		# Reads from each of the ready sockets
		for x in ready:
			data = x.recv(1500)
			read_packet(data, x)

		# If 500ms has passed, send out BPDUs
		if (time.time() - t) > 0.5:
			send_bpdu()
			# Reset the timer
			t = time.time()
