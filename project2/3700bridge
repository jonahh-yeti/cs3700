#!/usr/bin/python -u    
# The -u makes output unbuffered, so it will show up immediately
import sys
import socket
import select
import json
import time

# pads the name with null bytes at the end
def pad(name):
        result = '\0' + name
        while len(result) < 108:
                result += '\0'
        return result

def packet(dest, form, message):
	packet = {'source': id, 'dest': dest, 'type':form, 'message':message}
	return str(json.dumps(packet))

def send_bpdu(sockets):
	message = {'id': id, 'root': root, 'cost': cost}
	for x in sockets:
		p = packet(x.getpeername(), 'bpdu', str(json.dumps(message)))
		x.sendall(p)
		#print p

def send_message(sockets, message):
	for x in sockets:
		x.sendall(message)

def read_packet(data, port):
	print data
	data = json.loads(data)
	if data['type'] == 'bpdu':
		print "BPDU: " + str(data)
		return read_bpdu(json.loads(data['message']), port)
	elif data['type'] == 'data':
		print "DATA: " + str(data)
		return process_data(data, port)
		
def process_data(data, port):
	global forwarding_table
	if port in designated_ports:
		if data['source'] not in forwarding_table:
			forwarding_table[data['source']] = port
		if data['dest'] in forwarding_table:
			send_message([forwarding_table[data['dest']]], str(json.dumps(data)))
		else:
			send_message(designated_ports + root_port, str(json.dumps(data)))

def read_bpdu(data, port):
	global cost, root, root_port, designated_ports
	d_root = data['root']
	d_cost = data['cost']
	if root_port != None and root == d_root:
		if cost < d_cost or (cost == d_cost and int(root, 16) < int(d_root, 16)):
			designated_ports.append(port)
	if (d_cost == cost and int(d_root, 16) < int(root, 16)) or (d_cost < cost):
		root = d_root
		cost = d_cost + 1
		root_port = port
		print "New root: " + id + "/" + root
		send_bpdu(sockets)
			
 
if __name__ == "__main__":
        id = sys.argv[1]
        LAN = sys.argv[2:]
        sockets = []
	root = id
	cost = 0
	root_port = None
	designated_ports = []
	forwarding_table = {}

        # creates sockets and connects to them
        for x in range(len(LAN)):
                s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
                s.connect(pad(LAN[x]))
                sockets.append(s)
        
        
        print "Bridge " + id + " starting up\n"
 
        # Main loop
	t = time.time()
        while True:
                # Calls select with all the sockets; change the timeout value (1)
                ready, ignore, ignore2 = select.select(sockets, [], [], 1)
		 
		# Reads from each of the ready sockets
                for x in ready:
                        data = x.recv(1500)
			read_packet(data, x)

		if (time.time() - t) > 0.5:
			send_bpdu(ready)
			t = time.time()
